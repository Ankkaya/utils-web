<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="在线图片裁剪工具，支持自由框选、水平垂直翻转，快速裁剪并下载图片">
  <meta name="keywords" content="图片裁剪,图片翻转,图片编辑,图像处理">
  <link rel="canonical" href="http://utils.ankkaya.top/tools/image-crop.html">

  <!-- Open Graph -->
  <meta property="og:title" content="图片裁剪工具 - 在线工具集合">
  <meta property="og:description" content="拖拽框选裁剪区域，支持水平垂直翻转，一键导出裁剪结果">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://utils.ankkaya.top/tools/image-crop.html">
  <meta property="og:site_name" content="在线工具集合">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="图片裁剪工具 - 在线工具集合">
  <meta name="twitter:description" content="自由裁剪、翻转图片并下载，高效图片编辑工具">
  <meta name="twitter:url" content="http://utils.ankkaya.top/tools/image-crop.html">

  <title>图片裁剪工具 - 在线工具集合</title>

  <!-- 阿里妈妈字体（阿里巴巴普惠体） -->
  <link rel="preconnect" href="https://at.alicdn.com" crossorigin>
  <style>
    @font-face {
      font-family: 'Alibaba PuHuiTi';
      src: url('https://at.alicdn.com/t/webfont_8r1xq8qjq8j.eot');
      src: url('https://at.alicdn.com/t/webfont_8r1xq8qjq8j.eot?#iefix') format('embedded-opentype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
  </style>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: ['selector', '[data-theme="dark"]'],
    }
  </script>

  <!-- 自定义样式 -->
  <link rel="stylesheet" href="../assets/css/main.css">

  <!-- 导航栏工具栏组件 -->
  <script src="../assets/js/navbar-toolbar.js"></script>

  <!-- 结构化数据 -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "图片裁剪工具",
    "url": "http://utils.ankkaya.top/tools/image-crop.html",
    "applicationCategory": "UtilityApplication",
    "description": "上传图片后自由拖拽框选裁剪区域，支持水平和垂直翻转操作，并可立即下载裁剪结果"
  }
  </script>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col">
  <!-- 导航栏 -->
  <navbar-toolbar page="tool"></navbar-toolbar>

  <!-- 主要内容 -->
  <main class="flex-grow container mx-auto px-4 py-8 max-w-5xl">
    <h1 class="text-3xl font-bold mb-6 flex items-center">
      <div class="w-10 h-10 bg-teal-100 dark:bg-teal-900 rounded-lg flex items-center justify-center mr-3">
        <svg class="w-6 h-6 text-teal-600 dark:text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M8 5H5a2 2 0 00-2 2v3m0 6v1a2 2 0 002 2h1m3 0h3m6 0h1a2 2 0 002-2v-1m0-6V9m0-6v1a2 2 0 01-2 2h-1m-6 0H9m0 0V5m6 0v3" />
        </svg>
      </div>
      图片裁剪工具
    </h1>

    <section class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6">
      <h2 class="text-xl font-semibold mb-4">上传图片</h2>
      <div class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center">
        <input type="file" id="cropImageInput" accept="image/*" class="hidden" />
        <label for="cropImageInput" class="cursor-pointer block">
          <svg class="w-16 h-16 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
          </svg>
          <p class="text-gray-600 dark:text-gray-400">点击选择图片或拖拽到此处</p>
          <p class="text-sm text-gray-500 mt-2">上传后拖拽画布创建选区，松开鼠标自动裁剪</p>
        </label>
      </div>
      <p id="cropTips" class="text-sm text-gray-500 dark:text-gray-400 mt-3 hidden"></p>
    </section>

    <section id="cropWorkspace" class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-6 hidden">
      <div class="flex flex-col lg:flex-row lg:space-x-8 space-y-6 lg:space-y-0">
        <div class="flex-1">
          <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-semibold">裁剪预览</h2>
            <span id="canvasInfo" class="text-sm text-gray-500 dark:text-gray-400"></span>
          </div>
          <div
            class="relative bg-gray-100 dark:bg-gray-900 rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700">
            <canvas id="cropCanvas" class="w-full h-full cursor-crosshair"></canvas>
            <div id="selectionHint"
              class="absolute top-4 left-4 bg-white/80 dark:bg-gray-800/80 text-xs px-3 py-1 rounded-lg text-gray-600 dark:text-gray-300 hidden">
              拖拽创建选区，在选区内可拖动调整位置
            </div>
          </div>
          <div class="mt-4 flex flex-wrap gap-3">
            <button id="clearSelectionButton"
              class="px-4 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">清除选区</button>
            <button id="flipHorizontalButton"
              class="px-4 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">水平翻转</button>
            <button id="flipVerticalButton"
              class="px-4 py-2 bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">垂直翻转</button>
          </div>
        </div>

        <div class="w-full lg:w-80">
          <h2 class="text-xl font-semibold mb-4">裁剪结果</h2>
          <div id="cropResultContainer"
            class="border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-900">
            <p id="cropPlaceholder" class="text-gray-500 dark:text-gray-400">完成裁剪后显示结果预览</p>
            <img id="cropResultImage" src="" alt="裁剪结果预览" class="hidden max-w-full rounded-lg">
            <p id="cropResultInfo" class="mt-3 text-sm text-gray-600 dark:text-gray-400 hidden"></p>
            <button id="downloadCropButton"
              class="mt-4 w-full px-4 py-2 theme-bg text-white rounded-lg theme-bg-hover transition-colors hidden">
              下载裁剪图片
            </button>
          </div>
          <div class="mt-6 text-sm text-gray-500 dark:text-gray-400 space-y-2">
            <p><strong>提示：</strong>按住鼠标左键拖拽创建选区，松开鼠标后自动完成裁剪。</p>
            <p>在裁剪框内鼠标变为移动图标，可拖动调整裁剪框位置。再次拖拽可重新选择区域。</p>
            <p>翻转操作对画布即时生效，裁剪结果将同步保持翻转效果。</p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- 页脚 -->
  <div id="footer-container"></div>

  <!-- 脚本 -->
  <script src="../assets/js/storage.js"></script>
  <script src="../assets/js/theme.js"></script>
  <script src="../assets/js/common.js"></script>
  <script src="../assets/js/analytics.js"></script>
  <script src="../assets/js/footer.js"></script>

  <script>
    const cropInput = document.getElementById('cropImageInput');
    const cropTips = document.getElementById('cropTips');
    const cropWorkspace = document.getElementById('cropWorkspace');
    const cropCanvas = document.getElementById('cropCanvas');
    const canvasInfo = document.getElementById('canvasInfo');
    const selectionHint = document.getElementById('selectionHint');

    const clearSelectionButton = document.getElementById('clearSelectionButton');
    const flipHorizontalButton = document.getElementById('flipHorizontalButton');
    const flipVerticalButton = document.getElementById('flipVerticalButton');
    const downloadCropButton = document.getElementById('downloadCropButton');

    const cropResultImage = document.getElementById('cropResultImage');
    const cropResultInfo = document.getElementById('cropResultInfo');
    const cropPlaceholder = document.getElementById('cropPlaceholder');

    const dropZone = cropInput.parentElement.parentElement;

    let canvasCtx = cropCanvas.getContext('2d');
    let imageElement = new Image();
    let displayScale = 1;
    let flipHorizontal = false;
    let flipVertical = false;

    let selection = null;
    let isSelecting = false;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    let startPoint = { x: 0, y: 0 };

    let originalDataUrl = '';
    let originalFile = null;
    let cropObjectUrl = '';

    function resetCropObjectUrl() {
      if (cropObjectUrl) {
        URL.revokeObjectURL(cropObjectUrl);
        cropObjectUrl = '';
      }
    }

    function updateCanvasSize(width, height) {
      const maxWidth = 900;
      const maxHeight = 600;

      displayScale = Math.min(1, maxWidth / width, maxHeight / height);
      cropCanvas.width = Math.round(width * displayScale);
      cropCanvas.height = Math.round(height * displayScale);

      canvasInfo.textContent = `显示尺寸: ${cropCanvas.width}×${cropCanvas.height} | 原尺寸: ${width}×${height}`;
    }

    function drawCanvas() {
      canvasCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);

      canvasCtx.save();
      canvasCtx.translate(flipHorizontal ? cropCanvas.width : 0, flipVertical ? cropCanvas.height : 0);
      canvasCtx.scale(flipHorizontal ? -1 : 1, flipVertical ? -1 : 1);
      canvasCtx.drawImage(imageElement, 0, 0, cropCanvas.width, cropCanvas.height);
      canvasCtx.restore();

      if (selection) {
        canvasCtx.save();
        // 绘制半透明遮罩在裁剪框区域
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.35)';
        canvasCtx.fillRect(selection.x, selection.y, selection.width, selection.height);

        // 绘制裁剪框边框
        canvasCtx.strokeStyle = '#3b82f6';
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeRect(selection.x, selection.y, selection.width, selection.height);

        canvasCtx.setLineDash([6, 4]);
        canvasCtx.strokeStyle = 'rgba(255,255,255,0.8)';
        canvasCtx.strokeRect(selection.x, selection.y, selection.width, selection.height);
        canvasCtx.restore();
      }
    }

    function handleFile(file) {
      if (!file.type.startsWith('image/')) {
        Utils.showToast('请选择图片文件', 'error');
        return;
      }

      if (file.size > 30 * 1024 * 1024) {
        Utils.showToast('图片大小超过 30MB，请先压缩或更换图片', 'error');
        return;
      }

      originalFile = file;
      resetCropObjectUrl();
      cropResultImage.classList.add('hidden');
      cropResultInfo.classList.add('hidden');
      cropPlaceholder.classList.remove('hidden');
      downloadCropButton.classList.add('hidden');

      const reader = new FileReader();
      reader.onload = (event) => {
        originalDataUrl = event.target.result;
        imageElement = new Image();
        imageElement.onload = () => {
          updateCanvasSize(imageElement.naturalWidth, imageElement.naturalHeight);
          selection = null;
          isSelecting = false;
          isDragging = false;
          flipHorizontal = false;
          flipVertical = false;
          cropCanvas.style.cursor = 'crosshair';
          drawCanvas();
          cropWorkspace.classList.remove('hidden');
          cropTips.textContent = `当前图片大小: ${Utils.formatFileSize(file.size)}，拖拽画布创建裁剪区域。`;
          cropTips.classList.remove('hidden');
          selectionHint.classList.remove('hidden');
          Storage.session.set('lastCropImage', originalDataUrl);
          Analytics.trackEvent('image_crop', 'upload');
        };
        imageElement.onerror = () => {
          Utils.showToast('图片加载失败', 'error');
        };
        imageElement.src = originalDataUrl;
      };
      reader.onerror = () => {
        Utils.showToast('读取文件失败', 'error');
      };
      reader.readAsDataURL(file);
    }

    function setSelection(newSelection) {
      if (!newSelection) {
        selection = null;
        drawCanvas();
        return;
      }

      const clamped = { ...newSelection };
      clamped.x = Math.max(0, Math.min(clamped.x, cropCanvas.width));
      clamped.y = Math.max(0, Math.min(clamped.y, cropCanvas.height));
      clamped.width = Math.max(1, Math.min(cropCanvas.width - clamped.x, clamped.width));
      clamped.height = Math.max(1, Math.min(cropCanvas.height - clamped.y, clamped.height));
      selection = clamped;
      drawCanvas();
    }

    function canvasPointFromEvent(event) {
      const rect = cropCanvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) * (cropCanvas.width / rect.width);
      const y = (event.clientY - rect.top) * (cropCanvas.height / rect.height);
      return { x, y };
    }

    // 检查点是否在裁剪框内
    function isPointInSelection(point) {
      if (!selection) return false;
      return point.x >= selection.x &&
        point.x <= selection.x + selection.width &&
        point.y >= selection.y &&
        point.y <= selection.y + selection.height;
    }

    function handleMouseDown(event) {
      if (!originalDataUrl) return;
      const point = canvasPointFromEvent(event);

      // 如果已有选区且鼠标在选区内，则拖动选区
      if (selection && isPointInSelection(point)) {
        isDragging = true;
        dragOffset.x = point.x - selection.x;
        dragOffset.y = point.y - selection.y;
        return;
      }

      // 否则创建新选区
      isSelecting = true;
      isDragging = false;
      startPoint = point;
      setSelection({ x: startPoint.x, y: startPoint.y, width: 1, height: 1 });
    }

    function handleMouseMove(event) {
      if (!originalDataUrl) return;
      const currentPoint = canvasPointFromEvent(event);

      // 如果正在拖动选区
      if (isDragging && selection) {
        const newX = currentPoint.x - dragOffset.x;
        const newY = currentPoint.y - dragOffset.y;

        // 限制在画布范围内
        const clampedX = Math.max(0, Math.min(newX, cropCanvas.width - selection.width));
        const clampedY = Math.max(0, Math.min(newY, cropCanvas.height - selection.height));

        setSelection({
          x: clampedX,
          y: clampedY,
          width: selection.width,
          height: selection.height
        });
        return;
      }

      // 如果正在创建新选区
      if (isSelecting) {
        const width = currentPoint.x - startPoint.x;
        const height = currentPoint.y - startPoint.y;
        const newSelection = {
          x: width >= 0 ? startPoint.x : startPoint.x + width,
          y: height >= 0 ? startPoint.y : startPoint.y + height,
          width: Math.abs(width),
          height: Math.abs(height)
        };
        setSelection(newSelection);
        return;
      }

      // 更新鼠标光标样式
      if (selection && isPointInSelection(currentPoint)) {
        cropCanvas.style.cursor = 'move';
      } else {
        cropCanvas.style.cursor = 'crosshair';
      }
    }

    function handleMouseUp() {
      if (isDragging) {
        isDragging = false;
        // 拖动结束后自动裁剪
        if (selection && selection.width >= 5 && selection.height >= 5) {
          performCrop();
        }
        return;
      }

      if (!isSelecting) return;
      isSelecting = false;
      if (selection && (selection.width < 5 || selection.height < 5)) {
        Utils.showToast('选区过小，请重新选择', 'error');
        selection = null;
        drawCanvas();
        return;
      }
      // 如果选区有效，自动完成裁剪
      if (selection && selection.width >= 5 && selection.height >= 5) {
        performCrop();
      }
    }

    function performCrop() {
      if (!selection) {
        Utils.showToast('请先框选裁剪区域', 'error');
        return;
      }

      const actualWidth = Math.round(selection.width / displayScale);
      const actualHeight = Math.round(selection.height / displayScale);

      if (actualWidth <= 0 || actualHeight <= 0) {
        Utils.showToast('裁剪区域无效，请重新选择', 'error');
        return;
      }

      let sourceX = Math.round(selection.x / displayScale);
      let sourceY = Math.round(selection.y / displayScale);

      if (flipHorizontal) {
        sourceX = Math.round(imageElement.naturalWidth - (selection.x + selection.width) / displayScale);
      }
      if (flipVertical) {
        sourceY = Math.round(imageElement.naturalHeight - (selection.y + selection.height) / displayScale);
      }

      const sourceWidth = Math.min(actualWidth, imageElement.naturalWidth);
      const sourceHeight = Math.min(actualHeight, imageElement.naturalHeight);

      const canvas = document.createElement('canvas');
      canvas.width = sourceWidth;
      canvas.height = sourceHeight;
      const ctx = canvas.getContext('2d');

      ctx.save();
      if (flipHorizontal || flipVertical) {
        ctx.translate(flipHorizontal ? sourceWidth : 0, flipVertical ? sourceHeight : 0);
        ctx.scale(flipHorizontal ? -1 : 1, flipVertical ? -1 : 1);
      }
      ctx.drawImage(
        imageElement,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        0,
        0,
        sourceWidth,
        sourceHeight
      );
      ctx.restore();

      canvas.toBlob((blob) => {
        if (!blob) {
          Utils.showToast('裁剪失败，请重试', 'error');
          return;
        }

        resetCropObjectUrl();
        cropObjectUrl = URL.createObjectURL(blob);
        cropResultImage.src = cropObjectUrl;
        cropResultImage.classList.remove('hidden');
        cropResultInfo.textContent = `尺寸: ${sourceWidth}×${sourceHeight} | 大小: ${Utils.formatFileSize(blob.size)}`;
        cropResultInfo.classList.remove('hidden');
        cropPlaceholder.classList.add('hidden');
        downloadCropButton.classList.remove('hidden');

        Storage.session.set('lastCropResult', cropObjectUrl);
        Analytics.trackEvent('image_crop', 'crop');
      }, 'image/png');
    }

    function downloadCroppedImage() {
      if (!cropObjectUrl) {
        Utils.showToast('暂无裁剪结果', 'error');
        return;
      }

      const a = document.createElement('a');
      const filename = originalFile ? originalFile.name.replace(/\.[^.]+$/, '') + '_cropped.png' : 'cropped_image.png';
      a.href = cropObjectUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      Analytics.trackEvent('image_crop', 'download');
    }

    function clearSelection() {
      selection = null;
      isDragging = false;
      isSelecting = false;
      cropCanvas.style.cursor = 'crosshair';
      drawCanvas();
      selectionHint.classList.remove('hidden');
    }

    function toggleFlipHorizontal() {
      flipHorizontal = !flipHorizontal;
      drawCanvas();
      selectionHint.classList.add('hidden');
      Analytics.trackEvent('image_crop', 'flip_horizontal');
    }

    function toggleFlipVertical() {
      flipVertical = !flipVertical;
      drawCanvas();
      selectionHint.classList.add('hidden');
      Analytics.trackEvent('image_crop', 'flip_vertical');
    }

    cropInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        handleFile(file);
      }
    });

    cropCanvas.addEventListener('mousedown', handleMouseDown);
    cropCanvas.addEventListener('mousemove', handleMouseMove);
    cropCanvas.addEventListener('mouseleave', () => {
      if (!isSelecting && !isDragging) {
        cropCanvas.style.cursor = 'crosshair';
      }
    });
    window.addEventListener('mouseup', handleMouseUp);

    cropCanvas.addEventListener('touchstart', (event) => {
      if (!originalDataUrl) return;
      event.preventDefault();
      const touch = event.touches[0];
      const mockEvent = { clientX: touch.clientX, clientY: touch.clientY };
      // 需要先获取点坐标来判断是否在选区内
      const point = canvasPointFromEvent(mockEvent);
      if (selection && isPointInSelection(point)) {
        isDragging = true;
        dragOffset.x = point.x - selection.x;
        dragOffset.y = point.y - selection.y;
      } else {
        isSelecting = true;
        startPoint = point;
        setSelection({ x: startPoint.x, y: startPoint.y, width: 1, height: 1 });
      }
    }, { passive: false });

    cropCanvas.addEventListener('touchmove', (event) => {
      if (!originalDataUrl) return;
      event.preventDefault();
      const touch = event.touches[0];
      handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }, { passive: false });

    cropCanvas.addEventListener('touchend', () => {
      handleMouseUp();
    });

    downloadCropButton.addEventListener('click', downloadCroppedImage);
    clearSelectionButton.addEventListener('click', clearSelection);
    flipHorizontalButton.addEventListener('click', toggleFlipHorizontal);
    flipVerticalButton.addEventListener('click', toggleFlipVertical);

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      const themeColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
      dropZone.style.borderColor = themeColor;
      dropZone.style.backgroundColor = themeColor + '20';
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '';
      dropZone.style.backgroundColor = '';
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '';
      dropZone.style.backgroundColor = '';
      const file = e.dataTransfer.files[0];
      if (file) {
        handleFile(file);
      }
    });

    window.addEventListener('beforeunload', resetCropObjectUrl);

    window.addEventListener('DOMContentLoaded', () => {
      const lastImage = Storage.session.get('lastCropImage');
      if (lastImage) {
        originalDataUrl = lastImage;
        imageElement = new Image();
        imageElement.onload = () => {
          updateCanvasSize(imageElement.naturalWidth, imageElement.naturalHeight);
          drawCanvas();
          cropWorkspace.classList.remove('hidden');
          cropTips.textContent = '已恢复上次上传的图片数据，可直接开始裁剪。';
          cropTips.classList.remove('hidden');
        };
        imageElement.src = lastImage;
      }
    });
  </script>
</body>

</html>